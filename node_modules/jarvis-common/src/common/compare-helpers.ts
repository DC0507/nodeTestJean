type JSONObject = { [key: string]: any };

/**
 * Compare two arrays and return true if they are the same, false otherwise.
 * @param arr1 - The first array
 * @param arr2 - The second array
 * @returns True if the arrays are the same, false otherwise
 */
export function arraysDeepEqual(arr1: any[], arr2: any[]): boolean {
  if (arr1.length !== arr2.length) return false;
  for (let i = 0; i < arr1.length; i++) {
    if (Array.isArray(arr1[i]) && Array.isArray(arr2[i])) {
      if (!arraysDeepEqual(arr1[i], arr2[i])) return false;
    } else if (
      typeof arr1[i] === 'object' &&
      arr1[i] !== null &&
      typeof arr2[i] === 'object' &&
      arr2[i] !== null
    ) {
      if (!compareObjects(arr1[i], arr2[i])) return false;
    } else if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
// temp version that shows all attributes, can be replaced with one below eventually.

/**
 * Compare two objects and return an array of strings describing the differences.
 * @param obj1 - The first object
 * @param obj2 - The second object
 * @param attributesFilter - An array of attributes to compare
 * @param parentKey - The parent key of the objects
 * @returns An array of strings describing the differences
 */
export function compareObjects(
  obj1: JSONObject | null,
  obj2: JSONObject | null,
  attributesFilter: string[] = [],
  parentKey = '',
): string[] {
  const changes: string[] = [];

  // Determine the keys to compare based on the level of recursion and provided filters
  const keysToCompare = new Set<string>();
  if (parentKey === '' && attributesFilter.length > 0) {
    attributesFilter.forEach((attr) => keysToCompare.add(attr));
  } else {
    Object.keys(obj1 || {})
      .concat(Object.keys(obj2 || {}))
      .forEach((key) => keysToCompare.add(key));
  }

  keysToCompare.forEach((key) => {
    const fullKey = parentKey ? `${parentKey}.${key}` : key;
    const value1 = obj1 ? obj1[key] : undefined;
    const value2 = obj2 ? obj2[key] : undefined;

    // Check for array and direct value comparison
    if (Array.isArray(value1) && Array.isArray(value2)) {
      if (!arraysDeepEqual(value1, value2)) {
        changes.push(
          `${fullKey}: ${JSON.stringify(value1)} => ${JSON.stringify(value2)}`,
        );
      }
    } else if (
      typeof value1 === 'object' &&
      value1 !== null &&
      typeof value2 === 'object' &&
      value2 !== null
    ) {
      // For nested objects or arrays, recursively compare their properties or elements
      const nestedChanges = compareObjects(value1, value2, [], fullKey);
      if (nestedChanges.length === 0) {
        // If no differences, still show the attribute
        changes.push(
          `${fullKey}: ${JSON.stringify(value1)} => ${JSON.stringify(value2)}`,
        );
      } else {
        changes.push(...nestedChanges);
      }
    } else {
      // Direct value comparison, including for attributes that have not changed
      changes.push(
        `${fullKey}: ${
          value1 !== undefined ? JSON.stringify(value1) : 'nothing'
        } => ${value2 !== undefined ? JSON.stringify(value2) : 'nothing'}`,
      );
    }
  });

  return changes;
}
