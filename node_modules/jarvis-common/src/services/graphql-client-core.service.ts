import {
  ApolloClient,
  InMemoryCache,
  NormalizedCacheObject,
  HttpLink,
  ApolloLink,
  from,
  DefaultOptions,
} from '@apollo/client';
import fetch from 'cross-fetch';
import { onError } from '@apollo/client/link/error';
import { loadErrorMessages, loadDevMessages } from '@apollo/client/dev';
export const GRAPHQL_MINDATE = new Date('1990-01-01T00:00:00');

export interface GraphQLClientConfig {
  token?: string | null;
  apikey?: string | null;
  uri: string;
}

const errorLink = onError(({ graphQLErrors, networkError }: any) => {
  if (graphQLErrors)
    graphQLErrors.forEach(({ message, locations, path }: any) =>
      console.log(
        `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`,
      ),
    );

  if (networkError) console.log(`[Network error]: ${networkError}`);
});

loadDevMessages();
loadErrorMessages();

const authLink = (
  token: string | null | undefined,
  apikey: string | null | undefined,
) => {
  return new ApolloLink((operation: any, forward: any) => {
    if (!token && !apikey) {
      throw new Error('No token or APIKEY provided');
    }
    // Define a type for the headers
    const context: { headers: { authorization?: string; apikey?: string } } = {
      headers: {},
    };
    // if a token is provided, use it
    if (token) {
      context.headers.authorization = `Bearer ${token}`;
    }
    // if an apikey is provided, use it
    if (apikey && !token) {
      context.headers.apikey = apikey;
    }

    // set the context headers
    operation.setContext(context);
    // Call the next link in the middleware chain.
    return forward(operation);
  });
};

export class GraphQLClientCoreService {
  client: ApolloClient<NormalizedCacheObject>;

  public extractArrayResults<T>(response: { data: any }): T[] {
    return response.data[Object.keys(response.data)[0]].edges.map(
      (x: { node: T }) => x.node,
    );
  }

  constructor(config: GraphQLClientConfig) {
    const cache = new InMemoryCache({
      addTypename: false,
    });
    // turning query fetch policy to network-only so we always get most current database view of the data.. required for sync
    const defaultOptions: DefaultOptions = {
      watchQuery: {
        fetchPolicy: 'cache-and-network',
        errorPolicy: 'ignore',
      },
      query: {
        fetchPolicy: 'network-only',
        errorPolicy: 'all',
      },
      mutate: {
        errorPolicy: 'all',
      },
    };
    this.client = new ApolloClient({
      cache: cache,
      defaultOptions: defaultOptions,
      link: from([
        errorLink,
        authLink(config?.token, config?.apikey).concat(
          new HttpLink({ uri: config.uri, fetch }),
        ),
      ]),
    });
  }
}
