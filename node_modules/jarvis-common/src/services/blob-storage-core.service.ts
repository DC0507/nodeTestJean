import { ContainerClient } from '@azure/storage-blob';
import {
  BlobServiceClient,
  StorageSharedKeyCredential,
  BlobSASPermissions,
  BlobGenerateSasUrlOptions,
} from '@azure/storage-blob';

export interface BlobClientConfig {
  account: string;
  accountKey: string;
}

export class DirectoryEntry {
  name: string;
}

export class DirectoryListing {
  constructor(path: string) {
    this.path = path;
    this.files = [];
    this.subFolders = [];
  }
  path: string;
  files: DirectoryEntry[];
  subFolders: DirectoryEntry[];
}

export class BlobStorageCoreService {
  private blobServiceClient: BlobServiceClient;
  private sharedKeyCredential: StorageSharedKeyCredential;

  constructor(config: BlobClientConfig) {
    if (!config.account) throw Error('missing config variable "account"');
    if (!config.accountKey) throw Error('missing config variable "accountKey"');

    this.sharedKeyCredential = new StorageSharedKeyCredential(
      config.account,
      config.accountKey,
    );
    this.blobServiceClient = new BlobServiceClient(
      `https://${config.account}.blob.core.windows.net`,
      this.sharedKeyCredential,
    );
  }

  /*   private getBlobSasUri(containerClient, blobName, storedPolicyName) {
    const sasOptions: BlobSASSignatureValues = {
      containerName: containerClient.containerName,
      blobName: blobName,
    };

    if (storedPolicyName == null) {
      sasOptions.startsOn = new Date();
      sasOptions.expiresOn = new Date(new Date().valueOf() + 3600 * 1000);
      sasOptions.permissions = BlobSASPermissions.parse('r');
    } else {
      sasOptions.identifier = storedPolicyName;
    }

    const sasToken = generateBlobSASQueryParameters(
      sasOptions,
      this.sharedKeyCredential,
    ).toString();

    return `${containerClient.getBlockBlobClient(blobName).url}?${sasToken}`;
  } */

  getOrCreateContainer(containerName: string): ContainerClient {
    const containerClient =
      this.blobServiceClient.getContainerClient(containerName);
    containerClient.createIfNotExists();
    return containerClient;
  }

  async uploadFile(file: any, containerName: string) {
    const blobClient = this.getOrCreateContainer(
      containerName,
    ).getBlockBlobClient(file.originalname);
    const blobUrl = blobClient.url;

    // Set the content type (assuming the file is an MP4)
    let blobContentType = 'application/octet-stream';
    if (file.originalname.endsWith('.mp4')) {
      blobContentType = 'video/mp4';
    } else if (file.originalname.endsWith('.pdf')) {
      blobContentType = 'application/pdf';
    } else if (file.originalname.endsWith('.jpg')) {
      blobContentType = 'image/jpeg';
    }

    const uploadOptions = {
      blobHTTPHeaders: {
        blobContentType,
      },
    };

    await blobClient.uploadData(file.buffer, uploadOptions);
    return blobUrl;
  }

  async uploadBuffer(buffer: Buffer, name: string, containerName: string) {
    const blobClient =
      this.getOrCreateContainer(containerName).getBlockBlobClient(name);

    await blobClient.uploadData(buffer);
  }

  async listBlobs(
    path: string,
    containerName: string,
  ): Promise<DirectoryListing> {
    const blobClient = this.getOrCreateContainer(containerName);
    let prefix = undefined;
    if (path) {
      path =
        path.charAt[0] === '/' && path.length > 1 ? path.substring(1) : path;
      path = path.endsWith('/') ? path : path + '/';
      prefix = { prefix: path };
    } else {
      path = '';
    }
    const listing = new DirectoryListing(path);
    const iter = blobClient.listBlobsByHierarchy('/', prefix);
    let entity = await iter.next();
    while (!entity.done) {
      const item = entity.value;
      if (item.kind === 'prefix') {
        const name: string = item.name;
        listing.subFolders.push({
          name: name.replace(path, ''),
        });
      } else {
        const name: string = item.name;
        if (name !== path) {
          listing.files.push({
            name: name.replace(path, ''),
          });
        }
      }
      entity = await iter.next();
    }
    return listing;
  }

  async getPublicBlobUrl(name: string, containerName: string): Promise<string> {
    const blob = await this.blobServiceClient
      .getContainerClient(containerName)
      .getBlobClient(name);
    return blob.url;
  }

  async getSecureBlobUrl(name: string, containerName: string): Promise<string> {
    /* const container = this.blobServiceClient.getContainerClient(containerName);

    return this.getBlobSasUri(container, name, null); */
    //console.log(`connecting to ${containerName} to pull blob ${name}`)
    const blobClient = this.blobServiceClient
      .getContainerClient(containerName)
      .getBlobClient(name);

    const sasOptions: BlobGenerateSasUrlOptions = {};
    sasOptions.startsOn = new Date();
    sasOptions.expiresOn = new Date(new Date().valueOf() + 3600 * 1000);
    sasOptions.permissions = BlobSASPermissions.parse('r');
    return blobClient.generateSasUrl(sasOptions);
  }
}
