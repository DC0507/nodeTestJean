"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchRelationMutation = void 0;
const client_1 = require("@apollo/client");
class BatchRelationMutation {
    constructor(entity, id, returnAttribute = 'id') {
        this.inputs = [];
        this.mutations = [];
        this.variables = [];
        this.entity = entity;
        this.id = id;
        this.returnAttribute = returnAttribute;
    }
    getInputSignature() {
        let results = '';
        for (let i = 0; i < this.variables.length; i++) {
            results = results + `\t$input${i}: ${this.inputs[i]}!\n`;
        }
        return results;
    }
    getCallSignature() {
        let results = '';
        for (let i = 0; i < this.variables.length; i++) {
            results =
                results +
                    `\tm${i}: ${this.mutations[i]} (input: $input${i}) {  ${this.returnAttribute}  }\n`;
        }
        return results;
    }
    getVariablesObject() {
        const results = {};
        for (let i = 0; i < this.variables.length; i++) {
            results[`input${i}`] = this.variables[i];
        }
        return results;
    }
    getMutationSignature() {
        return `
  mutation executeBatch (
  ${this.getInputSignature()}) 
  {
  ${this.getCallSignature()}
  }
  `;
    }
    getMutationObject() {
        const x = {
            mutation: (0, client_1.gql)(this.getMutationSignature()),
            variables: this.getVariablesObject(),
        };
        return x;
    }
    set(relation, value) {
        if (value) {
            this.inputs.push(`Set${relation}On${this.entity}Input`);
            this.mutations.push(`set${relation}On${this.entity}`);
            if (Array.isArray(value))
                this.variables.push({ id: this.id, relationIds: value });
            else
                this.variables.push({ id: this.id, relationId: value });
        }
        return this;
    }
    remove(relation, value, action = 'Set') {
        if (value) {
            this.inputs.push(`Remove${relation}From${this.entity}Input`);
            this.mutations.push(`remove${relation}From${this.entity}`);
            if (Array.isArray(value))
                this.variables.push({ id: this.id, relationIds: value });
            else
                this.variables.push({ id: this.id, relationId: value });
        }
        return this;
    }
    async execute(client) {
        return await client.mutate(this.getMutationObject()).catch((err) => {
            console.log(JSON.stringify(err));
            throw err;
        });
    }
    printGraphQL() {
        console.log('-- mutation --');
        console.log(this.getMutationSignature());
        console.log('-- variables --');
        console.log(this.getVariablesObject());
        return this;
    }
}
exports.BatchRelationMutation = BatchRelationMutation;
//# sourceMappingURL=batch-relation-mutation.js.map