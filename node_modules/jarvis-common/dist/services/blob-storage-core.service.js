"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobStorageCoreService = exports.DirectoryListing = exports.DirectoryEntry = void 0;
const storage_blob_1 = require("@azure/storage-blob");
class DirectoryEntry {
}
exports.DirectoryEntry = DirectoryEntry;
class DirectoryListing {
    constructor(path) {
        this.path = path;
        this.files = [];
        this.subFolders = [];
    }
}
exports.DirectoryListing = DirectoryListing;
class BlobStorageCoreService {
    constructor(config) {
        if (!config.account)
            throw Error('missing config variable "account"');
        if (!config.accountKey)
            throw Error('missing config variable "accountKey"');
        this.sharedKeyCredential = new storage_blob_1.StorageSharedKeyCredential(config.account, config.accountKey);
        this.blobServiceClient = new storage_blob_1.BlobServiceClient(`https://${config.account}.blob.core.windows.net`, this.sharedKeyCredential);
    }
    getOrCreateContainer(containerName) {
        const containerClient = this.blobServiceClient.getContainerClient(containerName);
        containerClient.createIfNotExists();
        return containerClient;
    }
    async uploadFile(file, containerName) {
        const blobClient = this.getOrCreateContainer(containerName).getBlockBlobClient(file.originalname);
        const blobUrl = blobClient.url;
        let blobContentType = 'application/octet-stream';
        if (file.originalname.endsWith('.mp4')) {
            blobContentType = 'video/mp4';
        }
        else if (file.originalname.endsWith('.pdf')) {
            blobContentType = 'application/pdf';
        }
        else if (file.originalname.endsWith('.jpg')) {
            blobContentType = 'image/jpeg';
        }
        const uploadOptions = {
            blobHTTPHeaders: {
                blobContentType,
            },
        };
        await blobClient.uploadData(file.buffer, uploadOptions);
        return blobUrl;
    }
    async uploadBuffer(buffer, name, containerName) {
        const blobClient = this.getOrCreateContainer(containerName).getBlockBlobClient(name);
        await blobClient.uploadData(buffer);
    }
    async listBlobs(path, containerName) {
        const blobClient = this.getOrCreateContainer(containerName);
        let prefix = undefined;
        if (path) {
            path =
                path.charAt[0] === '/' && path.length > 1 ? path.substring(1) : path;
            path = path.endsWith('/') ? path : path + '/';
            prefix = { prefix: path };
        }
        else {
            path = '';
        }
        const listing = new DirectoryListing(path);
        const iter = blobClient.listBlobsByHierarchy('/', prefix);
        let entity = await iter.next();
        while (!entity.done) {
            const item = entity.value;
            if (item.kind === 'prefix') {
                const name = item.name;
                listing.subFolders.push({
                    name: name.replace(path, ''),
                });
            }
            else {
                const name = item.name;
                if (name !== path) {
                    listing.files.push({
                        name: name.replace(path, ''),
                    });
                }
            }
            entity = await iter.next();
        }
        return listing;
    }
    async getPublicBlobUrl(name, containerName) {
        const blob = await this.blobServiceClient
            .getContainerClient(containerName)
            .getBlobClient(name);
        return blob.url;
    }
    async getSecureBlobUrl(name, containerName) {
        const blobClient = this.blobServiceClient
            .getContainerClient(containerName)
            .getBlobClient(name);
        const sasOptions = {};
        sasOptions.startsOn = new Date();
        sasOptions.expiresOn = new Date(new Date().valueOf() + 3600 * 1000);
        sasOptions.permissions = storage_blob_1.BlobSASPermissions.parse('r');
        return blobClient.generateSasUrl(sasOptions);
    }
}
exports.BlobStorageCoreService = BlobStorageCoreService;
//# sourceMappingURL=blob-storage-core.service.js.map